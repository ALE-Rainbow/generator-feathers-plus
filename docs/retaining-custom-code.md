

## Retaining custom code

@feathersjs/cli's job ends when it generates the app scaffolding.
It doesn't know what you do afterwards with it.

Cli-plus is a `round-trip` generator.
Round-trip generators can take previously generated code,
identify custom changes made to it,
and regenerate the code (likely using different responses to the prompts)
along with those custom changes.

Cli-plus completes the round trip: generate -> customize -> regenerate -> customize => ...

The developer and the round-trip generator are in a more collaborative relationship.
They can both work on the scaffolding code.

### Retain developer modifications

You will usually add your own code to the generated modules.
Cli-plus can identify such additional code, as long as certain standards are followed,
and it will retain that added code when regenerating modules.

Some of the code generated by cli-plus is identified as default code which you may want to customize.
Any such customized code is also retained when modules are regenerated.

Let's look at a trivial example of these features.
An 'identical' module `src/index.js` is created by both @feathersjs/cli and cli-plus when `generate app` is run.
The cli-plus module has some extra decorative comments:
```js
server.on('listening', () => {
  //!<DEFAULT> code: listening_log
  logger.info('Feathers application started on http://%s:%d', app.get('host'), port);
  //!end
});

//!code: end //!end
```

Starting the server produces the expected log:
```text
Feathers application started on http://localhost:3030
```

The lines between `//!<DEFAULT> code: listening_log` and `//!end` contain default code named `listening_log`.
The `//!code: end //!end` line identifies a place named `end` where additional lines may be added.

Let's change the code to:
```js
server.on('listening', () => {
  //!code: listening_log <-- Note that <DEFAULT> was removed.
  logger.info('Hello world on http://%s:%d', app.get('host'), port);
  //!end
});

//!code: end
logger.info('Initialization complete. Waiting for server to start.'); 
//!end
```

Starting the server now logs:
```text
Initialization complete. Waiting for server to start.
Hello world on http://localhost:3030
```

Let's say you once more originally run `generate app` selecting only `socket.io` as a transport.
You then changed the code in `src/index.js` as described above.
Later on you realize you also need `REST` as a transport.
You can just rerun `generate app` with cli-plus and select both transports.
The regenerated modules will contain the code changes you made above.

### Where can code be added?

The short answer is "just about anywhere".
Insertion points are available anywhere it makes any sense to add code.

Here is `src/services/index.js` from the `cli-generator-example` repo:
```js
// Configure the Feathers services. (Can be re-generated.)
let comment = require('./comment/comment.service');
let like = require('./like/like.service');
let post = require('./post/post.service');
let relationship = require('./relationship/relationship.service');
let user = require('./user/user.service');

let graphql = require('./graphql/graphql.service');
//!code: imports //!end
//!code: init //!end

let moduleExports = function (app) { // eslint-disable-line no-unused-vars
  app.configure(comment);
  app.configure(like);
  app.configure(post);
  app.configure(relationship);
  app.configure(user);

  app.configure(graphql);
  //!code: func_return //!end
};

//!code: exports //!end
module.exports = moduleExports;

//!code: funcs //!end
//!code: end //!end
```

All the modules follow the same standards, e.g. starting with `imports` and `init`,
and ending with `funcs` and `end`.
Functions tend to end with names like `func_return` so you can add code to them.
You can replace or mutate the required modules at `init` as well as adding any initialization code.
You can modify or replace the exported value at `exports`.

Its trivial to add insertion points into the generator.
So create an issue if you need additional needs.
We'll add that insertion point, and you just regenerate the app to be able to use it.


### More realistic code customization

The previous example gets the idea across but its too trivial to appreciate the impact of the feature.

Cli-plus generates a module for every service named `src/services/service-name/validate.js`.
It contains JSON-schema which may be used to validate record contents before create, update and patch calls.
Part of the code may be similar to:
```js
const base = deepMerge.all([{},
  //!<DEFAULT> code: base
  {
    $schema: "http://json-schema.org/draft-05/schema",
    title: "User",
    description: "User database.",
    required: [
      "uuid",
      "email",
      "firstName",
      "lastName"
    ],
    properties: {
      _id: {
        type: ID
      },
      uuid: {
        type: ID
      },
      email: {
        type: "string"
      },
      firstName: {
        type: "string", maxLength: 30,
      },
      lastName: {
        type: "string", maxLength: 30,
      }
    }
  },
  //!end
  //!code: base_more //!end
]);
```

This 'base' JSON-schema is derived from the `service model`
-- A new concept cli-plus introduces further explained below --
and it is the basis for the validation schemas used for the different types of calls.

The developer may replace the default code named `base` to suit his use case.

It would probably be better however to mutate the default schema by adding, mutation or removing
properties by adding custom code to `base_more`, e.g.:
```js
//!code: base_more
{
  properties: {
    firstName: { minLength: 45 },
    initial: { type: 'string', maxLength: 1 }
  }
}
//!end
```
This would be better because, now, when you change the `service model`,
cli-plus will make appropriate changes to the base schema in its default code.
This is better than remembering to modify the base schema manually every time you change the service model.

### GraphQL examples

One of the main features of cli-plus is it ability to generate a GraphQL endpoint as well as the necessary resolvers.
A large number of carefully coded resolvers need to defined in a reasonably sized project,
so generating the resolvers is a quality-of-life feature.

However resolvers often have to be customized in unexpected ways.
You may need to change the sort order.
You may need to set props in context.params for certain hooks.
There is no practical end to the customizations required.

Here are some code snippets cli-plus may generate for a GraphQL endpoint:
```js
    // Feathers service resolvers
    User: {

      // comments: [Comment!]
      comments:
        //!<DEFAULT> code: resolver-User-comments
        (parent, args, content, ast) => {
          const feathersParams = convertArgsToFeathers(args, {
            query: { authorUuid: parent.uuid, $sort: undefined }, paginate: false
          });
          return comment.find(feathersParams).then(extractAllItems);
        },
        //!end

      // fullName: String!
      fullName:
        //!<DEFAULT> code: resolver-User-fullName-non
        (parent, args, content, ast) => { throw Error('GraphQL fieldName User.fullname is not calculated.'); },
        //!end

      // posts(query: JSON, params: JSON, key: JSON): [Post!]
      posts:
        //!<DEFAULT> code: resolver-User-posts
        (parent, args, content, ast) => {
          const feathersParams = convertArgsToFeathers(args, {
            query: { authorUuid: parent.uuid, $sort: undefined }, paginate: false
          });
          return post.find(feathersParams).then(extractAllItems);
        },
        //!end
    },
```
You can customize them as you wish, by defining a `$sort` order for example.
`fullname` is a calculated field.
Cli-plus, rather than inventing some specialized way for you to indicate what the calculation is,
just creates some default code for you to replace with the calculation.

```js
    // Raw SQL statement resolvers
    User: {

        // comments: [Comment!]
        comments: {
          //!<DEFAULT> code: fields-User-comments
          sqlJoin(ourTable, otherTable) { return `${ourTable}.uuid = ${otherTable}.author_uuid`; },
          orderBy(args, content) { return makeOrderBy(args, null); },
          where(table, args) { return makeWhere(table, args, 'uuid', undefined); },
          //!end
        },
        
        // posts(query: JSON, params: JSON, key: JSON): [Post!]
        posts: {
          //!<DEFAULT> code: fields-User-posts
          sqlJoin(ourTable, otherTable) { return `${ourTable}.uuid = ${otherTable}.author_uuid`; },
          orderBy(args, content) { return makeOrderBy(args, null); },
          where(table, args) { return makeWhere(table, args, 'uuid', undefined); },
          //!end
        },
    }
```

### Avoiding customization

@feathersjs/cli generates a module and doesn't care what you do thereafter.
You can do the same thing with cli-plus.
You can use it to generate modules and then prevent it from making changes therafter to some of them,
by using the `options.freeze` prop in `feathers-gen-specs.json`.